{"version":3,"file":"demo-bundle.js","sources":["../node_modules/tabbable/dist/index.esm.js","../index.js","js/with-open-web-component.js","js/index.js"],"sourcesContent":["/*!\n* tabbable 5.3.0-beta.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot} getShadowRoot returns the shadow root of an element or a boolean stating if it has a shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over content\n\n\n      var shadowRoot = element.shadowRoot || options.getShadowRoot(element);\n\n      if (shadowRoot) {\n        // add shadow dom scope\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // add light dom scope\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar isContentEditable = function isContentEditable(node) {\n  return node.contentEditable === 'true';\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  //\n  // isScope is positive for custom element with shadow root or slot that by default\n  // have tabIndex -1, but need to be sorted by document order in order for their\n  // content to be inserted in the correct position\n\n\n  if ((isScope || node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar noop = function noop() {};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      _ref$getShadowRoot = _ref.getShadowRoot,\n      getShadowRoot = _ref$getShadowRoot === void 0 ? noop : _ref$getShadowRoot;\n\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n\n      var parentElement = node.parentElement;\n      var rootNode = getRootNode(node);\n\n      if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement)) {\n        // fallback to zero area size for unreachable shadow dom\n        return isZeroArea(node);\n      } else if (node.assignedSlot) {\n        // iterate up slot\n        node = node.assignedSlot;\n      } else if (!parentElement && rootNode !== node.ownerDocument) {\n        // cross shadow boundary\n        node = rootNode.host;\n      } else {\n        // iterate up normal dom\n        node = parentElement;\n      }\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    return isZeroArea(node);\n  }\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {\n    var parentNode = node.parentElement;\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            } // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n\n\n            return true;\n          }\n        } // the node isn't in a legend, so no matter where it is now, it'll be disabled\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","import { tabbable, focusable, isFocusable, isTabbable } from 'tabbable';\n\nconst activeFocusTraps = (function () {\n  const trapQueue = [];\n  return {\n    activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        const activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap(trap) {\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    },\n  };\n})();\n\nconst isSelectableInput = function (node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\nconst isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nconst isTabEvent = function (e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nconst delay = function (fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nconst findIndex = function (arr, fn) {\n  let idx = -1;\n\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nconst valueOrHandler = function (value, ...params) {\n  return typeof value === 'function' ? value(...params) : value;\n};\n\nconst getActualTarget = function (event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function'\n    ? event.composedPath()[0]\n    : event.target;\n};\n\nconst createFocusTrap = function (elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  const doc = userOptions?.document || document;\n\n  const config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    ...userOptions,\n  };\n\n  const state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    tabbableGroups: [],\n\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n  };\n\n  let trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  const getOption = (configOverrideOptions, optionName, configOptionName) => {\n    return configOverrideOptions &&\n      configOverrideOptions[optionName] !== undefined\n      ? configOverrideOptions[optionName]\n      : config[configOptionName || optionName];\n  };\n\n  const containersContain = function (element) {\n    return !!(\n      element &&\n      // DEBUG TODO: this doesn't look inside web components (even open ones),\n      //  which means if we're about to tab onto an element inside a web component,\n      //  even if we've found it via tabbable() with shadow DOM enabled, we're\n      //  going to think the elemene isn't contained, we're then going to bring\n      //  focus back into the trap (thinking it has escaped, because the fact we're\n      //  testing `element` means the browser moved focus to it) and it'll be to\n      //  the most recently focused node, which will make it look like the tab\n      //  key is stuck on the element just before the one in the web component...\n      //  See issue https://github.com/focus-trap/focus-trap/issues/643\n      state.containers.some((container) => container.contains(element))\n    );\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  const getNodeForOption = function (optionName, ...params) {\n    let optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue(...params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\n        `\\`${optionName}\\` was specified but was not a node, or did not return a node`\n      );\n    }\n\n    let node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\n          `\\`${optionName}\\` as selector refers to no known node`\n        );\n      }\n    }\n\n    return node;\n  };\n\n  const getInitialFocusNode = function () {\n    let node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        const firstTabbableGroup = state.tabbableGroups[0];\n        const firstTabbableNode =\n          firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  };\n\n  const updateTabbableNodes = function () {\n    state.tabbableGroups = state.containers\n      .map((container) => {\n        const tabbableNodes = tabbable(container, {\n          getShadowRoot: config.tabbableOptions?.getShadowRoot,\n        });\n\n        // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n        //  are a superset of tabbable nodes\n        const focusableNodes = focusable(container);\n\n        if (tabbableNodes.length > 0) {\n          return {\n            container,\n            firstTabbableNode: tabbableNodes[0],\n            lastTabbableNode: tabbableNodes[tabbableNodes.length - 1],\n\n            /**\n             * Finds the __tabbable__ node that follows the given node in the specified direction,\n             *  in this container, if any.\n             * @param {HTMLElement} node\n             * @param {boolean} [forward] True if going in forward tab order; false if going\n             *  in reverse.\n             * @returns {HTMLElement|undefined} The next tabbable node, if any.\n             */\n            nextTabbableNode(node, forward = true) {\n              // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n              //  from the DOM order), this __will not work__ because the list of focusableNodes,\n              //  while it contains tabbable nodes, does not sort its nodes in any order other\n              //  than DOM order, because it can't: Where would you place focusable (but not\n              //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n              // Support for positive tabindex is already broken and hard to manage (possibly\n              //  not supportable, TBD), so this isn't going to make things worse than they\n              //  already are, and at least makes things better for the majority of cases where\n              //  tabindex is either 0/unset or negative.\n              // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n              const nodeIdx = focusableNodes.findIndex((n) => n === node);\n              if (forward) {\n                return focusableNodes\n                  .slice(nodeIdx + 1)\n                  .find((n) => isTabbable(n));\n              }\n              return focusableNodes\n                .slice(0, nodeIdx)\n                .reverse()\n                .find((n) => isTabbable(n));\n            },\n          };\n        }\n\n        return undefined;\n      })\n      .filter((group) => !!group); // remove groups with no tabbable nodes\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (\n      state.tabbableGroups.length <= 0 &&\n      !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error(\n        'Your focus-trap must have at least one container with at least one tabbable node in it at all times'\n      );\n    }\n  };\n\n  const tryFocus = function (node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({ preventScroll: !!config.preventScroll });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  const getReturnFocusNode = function (previousActiveElement) {\n    const node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  const checkPointerDown = function (e) {\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target),\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  const checkFocusIn = function (e) {\n    const target = getActualTarget(e);\n    const targetContained = containersContain(target);\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  const checkTab = function (e) {\n    const target = getActualTarget(e);\n    updateTabbableNodes();\n\n    let destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      const containerIndex = findIndex(state.tabbableGroups, ({ container }) =>\n        container.contains(target)\n      );\n      const containerGroup =\n        containerIndex >= 0 ? state.tabbableGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode =\n            state.tabbableGroups[state.tabbableGroups.length - 1]\n              .lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        let startOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ firstTabbableNode }) => target === firstTabbableNode\n        );\n\n        if (\n          startOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target) &&\n              !isTabbable(target) &&\n              !containerGroup.nextTabbableNode(target, false)))\n        ) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          const destinationGroupIndex =\n            startOfGroupIndex === 0\n              ? state.tabbableGroups.length - 1\n              : startOfGroupIndex - 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        let lastOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ lastTabbableNode }) => target === lastTabbableNode\n        );\n\n        if (\n          lastOfGroupIndex < 0 &&\n          (containerGroup.container === target ||\n            (isFocusable(target) &&\n              !isTabbable(target) &&\n              !containerGroup.nextTabbableNode(target)))\n        ) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          const destinationGroupIndex =\n            lastOfGroupIndex === state.tabbableGroups.length - 1\n              ? 0\n              : lastOfGroupIndex + 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  const checkKey = function (e) {\n    if (\n      isEscapeEvent(e) &&\n      valueOrHandler(config.escapeDeactivates, e) !== false\n    ) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  const checkClick = function (e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  const addListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  };\n\n  const removeListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      const onActivate = getOption(activateOptions, 'onActivate');\n      const onPostActivate = getOption(activateOptions, 'onPostActivate');\n      const checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      const finishActivation = () => {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(\n          finishActivation,\n          finishActivation\n        );\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n\n    deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n\n      activeFocusTraps.deactivateTrap(trap);\n\n      const onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      const onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      const checkCanReturnFocus = getOption(\n        deactivateOptions,\n        'checkCanReturnFocus'\n      );\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      const returnFocus = getOption(\n        deactivateOptions,\n        'returnFocus',\n        'returnFocusOnDeactivate'\n      );\n\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(\n          getReturnFocusNode(state.nodeFocusedBeforeActivation)\n        ).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n\n    pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n\n      return this;\n    },\n\n    unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n\n      return this;\n    },\n\n    updateContainerElements(containerElements) {\n      const elementsAsArray = [].concat(containerElements).filter(Boolean);\n\n      state.containers = elementsAsArray.map((element) =>\n        typeof element === 'string' ? doc.querySelector(element) : element\n      );\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    },\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n\n  return trap;\n};\n\nexport { createFocusTrap };\n","const { createFocusTrap } = require('../../index');\n\nmodule.exports = () => {\n  const container = document.getElementById('with-open-web-component');\n\n  customElements.define(\n    'open-web-component',\n    class extends HTMLElement {\n      connectedCallback() {\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.innerHTML = `\n          <p>\n            <button id=\"with-open-web-component-button\">open-web-component</button>\n          </p>\n        `;\n      }\n    }\n  );\n\n  container.innerHTML = `\n    <button>button 1</button>\n    <button>button 2</button>\n    <button>button 3</button>\n    <open-web-component></open-web-component>\n    <button>button 4</button>\n    <button>button 5</button>\n    <p>\n      <button id=\"deactivate-with-open-web-component\" aria-describedby=\"with-open-web-component-heading\">\n        deactivate trap\n      </button>\n    </p>\n  `;\n\n  const focusTrap = createFocusTrap('#with-open-web-component', {\n    onActivate: () => container.classList.add('is-active'),\n    onDeactivate: () => container.classList.remove('is-active'),\n    tabbableOptions: { getShadowRoot: () => true },\n  });\n\n  document\n    .getElementById('activate-with-open-web-component')\n    .addEventListener('click', focusTrap.activate);\n  document\n    .getElementById('deactivate-with-open-web-component')\n    .addEventListener('click', focusTrap.deactivate);\n};\n","// DEBUG\n// require('./default')();\n// require('./animated-dialog')();\n// require('./animated-trigger')();\n// require('./escape-deactivates')();\n// require('./initial-element-no-escape')();\n// require('./initially-focused-container')();\n// require('./hidden-treasures')();\n// require('./nested')();\n// require('./sibling')();\n// require('./tricky-initial-focus')();\n// require('./input-activation')();\n// require('./delay')();\n// require('./radio')();\n// require('./iframe')();\n\n// // loading this in a Cypress env causes Chrome to fail in GitHub CI (even with\n// //  the `\"chromeWebSecurity\": false` option set in the cypress.json config file),\n// //  and causes FireFox to fail both locally and in CI due to security context\n// //  violations; but it's still a good demo to have, and at least we can test\n// //  it manually\n// // eslint-disable-next-line no-undef -- process is defined via Rollup\n// if (!process.env.IS_CYPRESS_ENV) {\n//   require('./in-iframe')();\n// }\n\n// require('./allow-outside-click')();\n// require('./click-outside-deactivates')();\n// require('./set-return-focus')();\n// require('./set-return-focus-function')();\n// require('./no-delay')();\n// require('./multiple-elements')();\n// require('./multiple-elements-delete')();\n// require('./multiple-elements-delete-all')();\n// require('./multiple-elements-multiple-traps')();\n// require('./in-open-shadow-dom')();\n// require('./negative-tabindex')();\n// require('./negative-tabindex-last')();\nrequire('./with-open-web-component')();\n"],"names":["candidateSelector","candidateSelectors","NoElement","matches","Element","getRootNode","prototype","element","ownerDocument","Array","apply","el","querySelectorAll","candidates","filter","elementsToCheck","content","assigned","length","nestedCandidates","getCandidatesIteratively","flatten","scope","_nestedCandidates","contentEditable","isContentEditable","node","tabindexAttr","parseInt","getAttribute","b","tabIndex","sortOrderedTabbables","documentOrder","tagName","isInput","isDetailsWithSummary","slice","child","nodes","form","checked","i","radioScope","name","radioSet","window","queryRadios","escape","err","console","type","isTabbableRadio","getBoundingClientRect","width","height","_node$getBoundingClie","displayCheck","isHidden","_ref","getShadowRoot","nodeUnderDetails","isDirectSummary","getComputedStyle","rootNode","isZeroArea","assignedSlot","parentElement","isDisabledFromFieldset","parentNode","children","isHiddenInput","options","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","getTabindex","regularTabbables","sortByOrder","orderedTabbables","isScope","item","candidateTabindex","elements","push","sortable","acc","sort","concat","tabbable","bind","focusable","activeFocusTraps","trapQueue","activateTrap","trap","activeTrap","pause","trapIndex","indexOf","splice","deactivateTrap","unpause","isSelectableInput","toLowerCase","select","isEscapeEvent","e","key","keyCode","isTabEvent","delay","fn","setTimeout","findIndex","arr","idx","every","value","valueOrHandler","params","getActualTarget","event","target","shadowRoot","composedPath","createFocusTrap","userOptions","doc","document","config","_objectSpread","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","getOption","configOverrideOptions","optionName","configOptionName","containersContain","some","container","contains","getNodeForOption","optionValue","Error","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","tabbableNodes","tabbableOptions","focusableNodes","lastTabbableNode","nextTabbableNode","forward","nodeIdx","n","find","isTabbable","reverse","group","tryFocus","focus","preventScroll","getReturnFocusNode","previousActiveElement","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","isFocusable","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkTab","destinationNode","containerIndex","containerGroup","shiftKey","startOfGroupIndex","destinationGroupIndex","destinationGroup","lastOfGroupIndex","checkKey","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","clearTimeout","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","Boolean","require$$0","withOpenWebComponent","getElementById","customElements","define","attachShadow","mode","innerHTML","HTMLElement","focusTrap","classList","add","remove"],"mappings":"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"}